"
The reduced graph of G is the graph G where each strongly connected components was merged into one vertice / node.

circuitsNodes instance variabel will collect all nodes created by merging nodes in a circuit.
"
Class {
	#name : #MalGraphReducer,
	#superclass : #MalGraphAlgorithm,
	#instVars : [
		'circuits',
		'circuitNodes'
	],
	#category : #Moose-Algos-Graph,
	#timestamp : 'ChristopheDemarey 3/24/2015 16:50'
}

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>addCircuitNodes [
	nodes addAll: circuitNodes
]

{
	#category : #running,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>findCircuits [
	| tarjanCircuits |
	tarjanCircuits := MalTarjan new
		nodesAndNextFrom: nodes;
		run;
		circuits.
	circuits := tarjanCircuits 
		collect: [ :circuit | 
			circuit collect: [ :each | self findNode: each model ] ]
]

{
	#category : #initialize-release,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>initialize [
	super initialize.
	circuitNodes := OrderedCollection new.
	circuits := OrderedCollection new
]

{
	#category : #merging,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>mergeNodesInCircuit: aNodeList [
	| sortedNodes |
	"ensure that we get the same order in nodes part of a cycle. MalTarjan uses a dictionary and order depends on model hash that can differ from a machine to another one."
	sortedNodes := aNodeList sort: [ :one :other | one model < other model ].
	circuitNodes add: (self nodeClass new
		mergedNodes: sortedNodes;
		model: (sortedNodes collect: #model);
		nextNodes: (self nextNodesFor: sortedNodes);
		previousNodes: (self previousNodesFor: sortedNodes);
		yourself)
]

{
	#category : #merging,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>mergeNodesInCircuits [
	circuits do: [ :each | self mergeNodesInCircuit: each ].
	self removeReferencesToMergedNodes.
	self removeMergedNodes.
	self addCircuitNodes
]

{
	#category : #computing,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>nextNodesFor: aNodeList [
	"compute next nodes for the future node replacing aNodeList"
	^ ((aNodeList flatCollect: #nextNodes as: Set)
		difference: aNodeList) asOrderedCollection
]

{
	#category : #configuration,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>nodeClass [
	^ MalReducedGraphNode
]

{
	#category : #computing,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>previousNodesFor: aNodeList [
	"compute previous nodes for the future node replacing aNodeList"
	^ ((aNodeList flatCollect: #previousNodes as: Set)
		difference: aNodeList) asOrderedCollection
]

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>removeCircularDependenciesFrom: circuitNode [
	circuitNode nextNodes removeAllSuchThat: [ :each | each = circuitNode ].
	circuitNode previousNodes removeAllSuchThat: [ :each | each = circuitNode ]
]

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>removeMergedNodes [
	nodes removeAll: (circuitNodes flatCollect: #mergedNodes)
]

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>removeReferencesToMergedNodes [
	circuitNodes do: 
		[ :circuitNode |
		self 
			updateReferencesTo: circuitNode mergedNodes
			by: circuitNode.
		self removeCircularDependenciesFrom: circuitNode ]
]

{
	#category : #running,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>run [
	self findCircuits.
	self mergeNodesInCircuits.
	^ nodes
]

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>updateNextNodesOf: mergedNode replacing: aNodeList by: anotherNode [
	mergedNode nextNodes
		do: [ :node | 
			node previousNodes
				removeAllFoundIn: aNodeList;
				addIfNotPresent: anotherNode ]
]

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>updatePreviousNodesOf: mergedNode replacing: aNodeList by: anotherNode [
	mergedNode previousNodes
		do: [ :node | 
			node nextNodes
				removeAllFoundIn: aNodeList;
				addIfNotPresent: anotherNode ]
]

{
	#category : #updating,
	#timestamp : ' 8/31/2017 05:26:37'
}
MalGraphReducer>>updateReferencesTo: aNodeList by: anotherNode [
	aNodeList do: 
		[ :mergedNode | 
		self 
			updatePreviousNodesOf: mergedNode
			replacing: aNodeList
			by: anotherNode.
		self 
			updateNextNodesOf: mergedNode
			replacing: aNodeList
			by: anotherNode ]
]
