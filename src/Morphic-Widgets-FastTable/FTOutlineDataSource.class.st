"
I'm a data source which will have many list of elements. My goal is to allow a FTOutlineTable to render me with separators between my differents items.

Users might want to subclass me to have better options.
"
Class {
	#name : #FTOutlineDataSource,
	#superclass : #FTDataSource,
	#instVars : [
		'items'
	],
	#category : #Morphic-Widgets-FastTable-DataSource,
	#timestamp : 'CyrilFerlicot 9/28/2015 17:36'
}

{
	#category : #'instance creation',
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource class>>items: aCollectionOfCollection [
	" I take a collection of collection of elements."

	^ self new
		items: aCollectionOfCollection;
		yourself
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>cellColumn: column row: rowIndex [
	| cell |
	cell := FTCellMorph new
		addMorphBack: (self elementAt: rowIndex) asMorph;
		yourself.
	(self needSeparatorBefore: rowIndex)
		ifTrue: [ cell withTopSeparator ].
	^ cell
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>elementAt: index [
	| tmpIndex |
	tmpIndex := index.
	self items
		do: [ :elements | 
			tmpIndex <= elements size
				ifTrue: [ ^ elements at: tmpIndex ]
				ifFalse: [ tmpIndex := tmpIndex - elements size ] ].
	self errorSubscriptBounds: index
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>headerColumn: column [
	column id ifNil: [ ^ nil ]. 
	^ FTCellMorph new 
		listCentering: #center;
		addMorph: column id asMorph;
		yourself
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>items [
	^ items
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>items: anObject [
	items := anObject
]

{
	#category : #testing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>needSeparatorBefore: index [
	| tmpIndex |
	index <= 1
		ifTrue: [ ^ false ].
	tmpIndex := index.
	self items
		do: [ :elements | 
			elements size >= tmpIndex
				ifTrue: [ ^ tmpIndex = 1 ]
				ifFalse: [ tmpIndex := tmpIndex - elements size ] ].
	self errorSubscriptBounds: index
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>newDataSourceMatching: aFTFilter [
	| newItems |
	newItems := items class withAll: (items collect: [ :coll | coll select: [ :each | aFTFilter matches: (self toString: each) ] ]).
	^ self class new items: newItems
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>numberOfRows [
	^ self items
		ifNotNil: [ | cpt |
			cpt := 0.
			self items do: [ :elements | cpt := cpt + elements size ].
			cpt ]
		ifNil: [ 0 ]
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:21'
}
FTOutlineDataSource>>searchText: aString [
	| index result |
	aString isEmptyOrNil
		ifTrue: [ ^ #() ].
	index := 0.
	result := OrderedCollection new.
	self items
		do: [ :elements | 
			elements
				do: [ :each | 
					index := index + 1.
					((self toString: each) beginsWith: aString)
						ifTrue: [ result add: index ] ] ].
	^ result asArray
]
