"
I'm the finderUI model in the MVC pattern.

I'm compute the search string and I construct a resultDictionary.
Then I throw events everywhere and my views are redrawn.
"
Class {
	#name : #Finder,
	#superclass : #Object,
	#instVars : [
		'searchingString',
		'selectedMethod',
		'selectedClass',
		'packagesSelection',
		'currentSearchMode',
		'environment',
		'resultDictionary',
		'useRegEx'
	],
	#category : #Tool-Finder,
	#timestamp : 'BenjaminVanRyseghem 9/15/2010 11:17'
}

{
	#category : #menu,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder class>>finderMenuOn: aBuilder  [
	"I build a menu"
	<worldMenu>
	(aBuilder item: #Finder)
		action: [self open];
		order: 0.10;
		parent: #Tools;
		help: 'Looking for something ?';
		icon: self icon.
	aBuilder withSeparatorAfter.	
]

{
	#category : #menu,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder class>>icon [
	"My menu icon"
	^ FinderUI icon
]

{
	#category : #menu,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder class>>open [
	^ self new open
]

{
	#category : #'tools registry',
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder class>>registerToolsOn: registry [
	"Add ourselves to registry. See [Smalltalk tools]" 

	registry register: self as: #finder

	
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>classSearch: aSelectBlock [
	| result |
	result := OrderedCollection new.
	self packagesSelection classesAndTraitsDo:[ :class | 
			(aSelectBlock value: class)
				ifTrue: [ result add: class ] ].
	^ result
]

{
	#category : #private-class,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>computeListOfClasses: aString [
	"Compute in the case I'm searching class names"
		
	^ self useRegEx
		ifTrue: [ | regex |
			regex := aString asRegex.
			self classSearch: [ :class | regex search: class name ]]
		ifFalse: [ 
			self classSearch: [ :class |
				class name includesSubstring: aString caseSensitive: false ]].
]

{
	#category : #private-example,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>computeWithMethodFinder: aString [
	"Compute the selectors for the single example of receiver and args, in the very top pane"

	| data result resultArray dataStrings methodFinder dataObjects temporarySearchResult statements |
	(aString includes: $.)
		ifFalse: [ ^ #() ].	"delete trailing period. This should be fixed in the Parser!"
	data := aString trimRight: [ :char | char isSeparator or: [ char = $. ] ].
	methodFinder := MethodFinder new.
	data := methodFinder cleanInputs: data.	"remove common mistakes"
	[ dataObjects := Smalltalk compiler evaluate: '{' , data , '}' ]
		on: SyntaxErrorNotification
		do: [ :e | 
			self inform: 'Syntax Error: ' , e errorMessage.
			^ #() ].	"#( data1 data2 result )"
	statements := (self class compiler parse: 'zort ' , data) body statements reject: [ :each | each isReturn ].
	dataStrings := statements
		collect: [ :node | 
			String
				streamContents: [ :strm | 
					node isMessage
						ifTrue: [ strm nextPut: $( ].
					strm << node formattedCode.
					node isMessage
						ifTrue: [ strm nextPut: $) ] ] ].
	dataObjects size < 2
		ifTrue: [ 
			self
				inform:
					'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment'
						withCRs.
			^ #() ].
	dataObjects := Array with: dataObjects allButLast with: dataObjects last.	"#( (data1 data2) result )"
	result := methodFinder
		load: dataObjects;
		findMessage.
	(result first beginsWith: 'no single method')
		ifFalse: [ 
			temporarySearchResult := self testObjects: dataObjects strings: dataStrings.
			dataObjects := temporarySearchResult second.
			dataStrings := temporarySearchResult third ].
	resultArray := self listFromResult: result.
	resultArray isEmpty
		ifTrue: [ self inform: result first ].
	dataStrings size = (dataObjects first size + 1)
		ifTrue: [ 
			resultArray := resultArray
				collect: [ :expression | 
					| newExp |
					newExp := expression.
					dataObjects first
						withIndexDo: [ :lit :i | newExp := newExp copyReplaceAll: 'data' , i printString with: (dataStrings at: i) ].
					newExp , ' --> ' , dataStrings last ] ].
	^ resultArray
]

{
	#category : #private-class,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>constructClassNamesDictionary [
	"Construct the dictionary in the case I'm searching in class names"
	
	| result listOfClasses |
	listOfClasses := self computeListOfClasses: self searchingString.
	result := Dictionary new.
	listOfClasses do: [:each | 
		result at: each put: (each selectors sort: [:a :b | a < b])].
	self resultDictionary: result.
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>constructDictionary [
	"I construct the adequate dictionary regarding the search mode"

	self searchingString isEmpty ifTrue: [ ^ self resultDictionary: Dictionary new].
	[ :job|
		job title: 'Searching...'.
		self isSelectorsSymbol
			ifTrue: [ self constructDictionaryWithMessagesNameSearch: self searchingString].
		self isClassNamesSymbol
			ifTrue: [ self constructClassNamesDictionary].
		self isSourceSymbol
			ifTrue: [ self constructSourceDictionary].
		self isExamplesSymbol
			ifTrue: [ self constructDictionaryWithMethodFinder: self searchingString].
		self isPragmasSymbol
			ifTrue: [ self constructDictionaryWithPragmaSearch: self searchingString ].
	] asJob run
]

{
	#category : #private-selector,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>constructDictionaryWithMessagesNameSearch: aString [
	"Construct dictionary when searching for selector"
	
	| result listOfMethods |
	result := Dictionary new.
	listOfMethods := self messagesNameSearch: aString.
	listOfMethods do: [:method || key value |
			key := method selector.
			value := method methodClass.
			(result includesKey: key)
				ifTrue: [ (result at: key) add: value]
				ifFalse: [ result at: key put: (OrderedCollection new add: value; yourself)]].
	self resultDictionary: result.
]

{
	#category : #private-example,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>constructDictionaryWithMethodFinder: aString [
	"construct dictionary when searching patterns"

	| result listOfStrings listOfSelectors |
	result := Dictionary new.
	listOfStrings := self computeWithMethodFinder: aString.
	listOfSelectors := listOfStrings collect: [ :each | self findSelector: each ].
	self packagesSelection classesDo:[ :class | 
			class methodsDo:  [ :method | 
					| index |
					(index := listOfSelectors indexOf: method selector) = 0
						ifFalse: [ 
							| key value |
							key := listOfStrings at: index.
							value := method methodClass.
							(result includesKey: key)
								ifTrue: [ (result at: key) add: value ]
								ifFalse: [ 
									result
										at: key
										put:
											(OrderedCollection new
												add: value;
												yourself) ] ] ] ].
	self resultDictionary: result
]

{
	#category : #private-pragma,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>constructDictionaryWithPragmaSearch: aString  [
	"construct dictionary when searching for pragmas"
	
	| dictionary |
	dictionary := self pragmaSearch: aString.
	dictionary keysDo:[ :k || result |
		result := Dictionary new.
		(dictionary at: k) do: [:method || key value |
				key := method selector.
				value := method methodClass.
				(result 
					at: key
					ifAbsentPut: OrderedCollection new ) add: value].
		dictionary at: k put: result ].
	self resultDictionary: dictionary.
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>constructSourceDictionary [
"construct dictionary when searching source"
	| result listOfMethods |
	result := Dictionary new.
	listOfMethods := self sourceSearch: self searchingString.
	listOfMethods do: [:method || key value |
		key := method selector.
		value := method methodClass.
		(result includesKey: key)
			ifTrue: [ (result at: key) add: value]
			ifFalse: [ result at: key put: (OrderedCollection new add: value; yourself)]].
	self resultDictionary: result.
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>currentSearchMode [
	"Getter"
	"I shoud answer a Symbol in :
		- #Selectors
		- #Classes
		- #Source
		- #Examples"
	
	 ^ currentSearchMode
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>currentSearchMode: aSymbol [
	"Setter"
	"If #Examples is selected, I disable the RegEx checkbo. Then I rebuild the resultDictionary"

	currentSearchMode := aSymbol.
	self isExamplesSymbol
		ifTrue: [ self disableUseRegEx]
		ifFalse:[ self enableUseRegEx].
		
	self update: #sourceCode.
	self constructDictionary
]

{
	#category : #default,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>defaultEnvironment [
	 ^ RBBrowserEnvironment new
]

{
	#category : #default,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>defaultPackagesSelection [
	 ^ self environment
]

{
	#category : #default,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>defaultString [
	^''
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>disableUseRegEx [
	"send a disable useRegEx dropbox event"
	^ self triggerEvent: #disableUseRegEx
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>enableUseRegEx [
	"send a enable useRegEx dropbox event"
	^ self triggerEvent: #enableUseRegEx
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>environment [
	 ^ environment 
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>environment: aCollection [

	 environment := aCollection
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>findSelector: aString [
	"Answer the selector of aString."

	| example tokens |
	example := aString.
	tokens := example parseLiterals.
	tokens size = 1 ifTrue: [^ tokens first].
	tokens first == #'^' ifTrue: [^ nil].
	(tokens second includes: $:) ifTrue: [^ example findSelector].
	Symbol hasInterned: tokens second ifTrue: [:aSymbol | ^ aSymbol].
	^ nil
]

{
	#category : #initialization,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>initialize [
	super initialize.
	searchingString := self defaultString.
	environment := self defaultEnvironment.
	packagesSelection := self defaultPackagesSelection.
	resultDictionary := Dictionary new.
	currentSearchMode := #Selectors.
	useRegEx := false.
	
]

{
	#category : #checkbox,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>isClassNamesSymbol [
	"answer if the current mode is Classes"
	^self currentSearchMode = #Classes
]

{
	#category : #checkbox,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>isExamplesSymbol [
	"Answer if the current mode is Examples"
	^self currentSearchMode = #Examples
]

{
	#category : #checkbox,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>isPragmasSymbol [
"answer if the current mode is Pragmas"
	^self currentSearchMode = #Pragmas
]

{
	#category : #checkbox,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>isSelectorsSymbol [
"answer if the current mode is Selectors"
	^self currentSearchMode = #Selectors
]

{
	#category : #checkbox,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>isSourceSymbol [
	"answer if the current mode is Source"
	^self currentSearchMode = #Source
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>listFromResult: resultOC [
	"The argument, resulOC, is of the form #('(data1 op data2)' '(...)'). Answer a sorted array."

	(resultOC first beginsWith: 'no single method') ifTrue: [^ #()].
	^ resultOC sort: [:a :b | 
		(a copyFrom: 6 to: a size) < (b copyFrom: 6 to: b size)].

]

{
	#category : #private-selector,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>messageSearchBlockFrom: aString [
	| exactMatch |
	
	exactMatch := aString first = $" and: [ aString last = $"].
	
	exactMatch ifFalse: [ 
		^ [ :method | 
			method selector includesSubstring: aString caseSensitive: false ]].
		
	 ^ (Symbol findInterned: (aString copyFrom: 2 to: aString size - 1))
		ifNil: [  nil ]
		ifNotNil: [ :aSymbol | 
			[ :method | method selector = aSymbol ]].
]

{
	#category : #private-selector,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>messagesNameSearch: aString [
	"I'm searching for selectors"
	^ self useRegEx
		ifTrue: [ | regex |
			regex := aString asRegex.
			self methodSearch: [ :method| 	regex search: method selector asString ]]
		ifFalse: [
			self methodSearch: (self messageSearchBlockFrom: aString)].
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>methodSearch: aSelectBlock  [
	| result | 
	result := OrderedCollection new.
	
	self packagesSelection classesAndTraits do:[ :class |
			class methodsDo: [ :method | 
				(aSelectBlock value: method) ifTrue: [ result add: method ]].
			class classSide methodsDo: [ :method | 
				(aSelectBlock value: method) ifTrue: [ result add: method ]]
			]
			displayingProgress: [ :aClass | aClass name ].
	^ result
]

{
	#category : #display,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>open [
	^ (FinderUI on: self) open
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>packagesSelection [
	"I should be a selection of classes"
	^packagesSelection
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>packagesSelection: aCollection [
	"I change the classes selection, then I rebuild the result dictionary"
	packagesSelection :=  aCollection.
	self constructDictionary.
]

{
	#category : #private-pragma,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>pragmaSearch: aString  [
	| result byCondition |
	" I choose a dictionary here because the next step is to group result by pragmas "
	result := Dictionary new.
	
	byCondition :=  self useRegEx 
		ifTrue: [[ :pragma | pragma keyword matchesRegexIgnoringCase: aString ]]
		ifFalse: [[ :pragma | pragma keyword includesSubstring: aString caseSensitive: false ]].
				
	(PragmaCollector filter: byCondition) reset; 
		do: [ :pragma |
			(result at: (pragma keyword) ifAbsentPut: OrderedCollection new)				
				add: pragma method ].
	^ result
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>resetEnvironment [
	"I send an event when I reset the environment"
	self environment: self defaultEnvironment.
	self triggerEvent: #resetEnvironment.
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>resultDictionary [
	"I should answer a dictionary"
	^resultDictionary
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>resultDictionary: aDictionary [
	"When the result dictionary is update, I send an event through the whole universe"

	resultDictionary := aDictionary.
	self triggerEvent: #updateResultDictionary.
	self selectedMethod: nil.
	self selectedClass: nil.
	self triggerEvent: #updateSourceCode.
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>searchingString [

	^searchingString
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>searchingString: aString [
	"When the search string is modified (in fact, when I make a search) I rebuild the result dictionary"

	searchingString := aString.
	self constructDictionary.
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>searchingStringSilently: aString [
	searchingString := aString.

]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>selectedClass [

	^selectedClass
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>selectedClass: aClass [
	"When the class seletion is changed, I send an event to UI"
	selectedClass := aClass.
	self triggerEvent: #updateSelectedClass
	
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>selectedMethod [
	"I should answer a CompiledMethod"
	^selectedMethod
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>selectedMethod: aMethod [
	"When the method seletion is changed, I send an event to UI"
	selectedMethod := aMethod.
	self triggerEvent: #updateSelectedMethod
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>selection: aSelectionHolder [
	"anObject is a selection holder"
	"Depending of the value of currentSearchMode, I fill selectedMethod and SelectedClass with the good items."
	"Then, I update the source code text area"

	| path methodNode method classNode class |
	(aSelectionHolder isNil or: [aSelectionHolder selectedNodePath isNil]) ifTrue: [
		self selectedClass: nil.
		self selectedMethod: nil.
		^self].
	path := aSelectionHolder selectedNodePath.
	self isSelectorsSymbol
		ifTrue: [
			path first isSingle
				ifTrue: [
					method := path first itemMethod selector.
					class := path first itemMethod methodClass ]
				ifFalse: [
					methodNode := path first.
					classNode := path at: 2 ifAbsent: [ nil ]]].
	self isClassNamesSymbol
		ifTrue: [
			classNode := path first.
			methodNode := path at: 2 ifAbsent:[nil]].
	self isSourceSymbol
		ifTrue: [
			methodNode := path first.
			classNode := path at: 2 ifAbsent:[nil]].
	self isExamplesSymbol
		ifTrue: [
			methodNode := path first.
			classNode := path at: 2 ifAbsent:[nil]].
	self isPragmasSymbol
		ifTrue: [
			methodNode := path at:2 ifAbsent: [ nil ].
			classNode := path at: 3 ifAbsent:[nil]].		

	classNode ifNotNil: [ class := classNode item ].
	self selectedClass: class.
	
	methodNode ifNotNil: [ method := methodNode item ].
	self selectedMethod: method.
	
	self triggerEvent: #updateSourceCode
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>sourceRegexSearch: aSearchString [
	| regex |
	regex := aSearchString asRegex.
	^ self methodSearch: [ :method | regex search: method sourceCode ]
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>sourceSearch: aSearchString [
	"I'm searching in sources"
	^ self useRegEx
		ifTrue: [ self sourceRegexSearch: aSearchString ]
		ifFalse:[ self sourceStringSearch: aSearchString ].
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>sourceStringSearch: aSearchString  [
	^ self 
		methodSearch: [ :method |
			method sourceCode includesSubstring: aSearchString caseSensitive: false ]
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>testObjects: dataObjects strings: dataStrings [
	"Try to make substitutions in the user's inputs and search for the selector again.
		1 no change to answer.
		2 answer Array -> OrderedCollection.
		2 answer Character -> String
		4 answer Symbol or String of len 1 -> Character
	For each of these, try straight, and try converting args:
		Character -> String
		Symbol or String of len 1 -> Character
	Return array with result, dataObjects, dataStrings.  Don't ever do a find on the same set of data twice."

	| selectors classes didUnmodifiedAnswer |
	
	selectors := {#asString. #first. #asOrderedCollection}.
	classes := {Character. String. Array}.
	didUnmodifiedAnswer := false.
	
	selectors withIndexDo: [:ansSel :ansInd | | tempDataObjects result tempDataStrings answerMod | 
		"Modify the answer object"
		answerMod := false.
		tempDataObjects := dataObjects copyTwoLevel.  
		tempDataStrings := dataStrings copy.
		(dataObjects last isKindOf: (classes at: ansInd)) ifTrue: [
			((ansSel ~~ #first) or: [dataObjects last size = 1]) ifTrue: [
				tempDataObjects at: tempDataObjects size put: (tempDataObjects last perform: ansSel).	"asString"
				tempDataStrings at: tempDataStrings size put: tempDataStrings last, ' ', ansSel.
				result := MethodFinder new load: tempDataObjects; findMessage.
				(result first beginsWith: 'no single method') ifFalse: [
					"found a selector!"
					^ Array with: result first with: tempDataObjects with: tempDataStrings].	
				answerMod := true]].

		selectors allButLast withIndexDo: [:argSel :argInd | | dds ddo | 
			"Modify an argument object"
			"for args, no reason to do Array -> OrderedCollection.  Identical protocol."
			didUnmodifiedAnswer not | answerMod ifTrue: [
			ddo := tempDataObjects copyTwoLevel. 
			dds := tempDataStrings copy.
			dataObjects first withIndexDo: [:arg :ind |
				(arg isKindOf: (classes at: argInd))  ifTrue: [
					((argSel ~~ #first) or: [arg size = 1]) ifTrue: [
						ddo first at: ind put: ((ddo first at: ind) perform: argSel).	"asString"
						dds at: ind put: (dds at: ind), ' ', argSel.
						result := MethodFinder new load: ddo; findMessage.
						(result first beginsWith: 'no single method') ifFalse: [
							"found a selector!"
						^ Array with: result first with: ddo with: dds].	
					didUnmodifiedAnswer not & answerMod not ifTrue: [
						didUnmodifiedAnswer := true].
					]]]]].
	].
	^ Array with: 'no single method does that function' with: dataObjects with: dataStrings
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>useRegEx [
	"I should answer a boolean that tells whether regExpression should be taken into account"
	 ^ useRegEx
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 05:26:26'
}
Finder>>useRegEx: aBoolean [

	useRegEx :=  aBoolean.
]
