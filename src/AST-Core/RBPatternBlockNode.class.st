"
RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.

Instance Variables:
	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.


"
Class {
	#name : #RBPatternBlockNode,
	#superclass : #RBBlockNode,
	#instVars : [
		'valueBlock'
	],
	#category : #AST-Core-Pattern,
	#timestamp : 'md 8/9/2005 14:56'
}

{
	#category : #visitor,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>acceptVisitor: aProgramNodeVisitor  [
	^aProgramNodeVisitor visitPatternBlockNode: self
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>addArgumentWithNameBasedOn: aString to: aRBBlockNode  [
	| name index vars |
	name := aString.
	vars := aRBBlockNode allDefinedVariables.
	index := 0.
	[vars includes: name] whileTrue: 
			[index := index + 1.
			name := name , index printString].
	aRBBlockNode 
		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>constructLookupNodeFor: aString in: aRBBlockNode  [
	| argumentNode |
	argumentNode := RBLiteralNode value: aString.
	
	^RBMessageNode 
		receiver: (RBVariableNode named: 'self')
		selector: #lookupMatchFor:in:
		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>copyInContext: aDictionary  [
	^ self replacingBlock value: aDictionary
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>createBlockFor: aRBBlockNode  [
	aRBBlockNode left: self left; right:self right.
	self replacePatternNodesIn: aRBBlockNode.
	^Smalltalk compiler 
		source: aRBBlockNode formattedCode;
		receiver: self;
		evaluate
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>createMatchingBlock [
	| newBlock |
	self arguments size > 2 
		ifTrue: 
			[self 
				error: 'Search blocks can only contain arguments for the node and matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	newBlock arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].
	newBlock arguments size = 1 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>createReplacingBlock [
	| newBlock |
	self arguments size > 1 
		ifTrue: 
			[self 
				error: 'Replace blocks can only contain an argument for the matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	self arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
]

{
	#category : #testing-matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>isPatternNode [
	^ true
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>lookupMatchFor: aString in: aDictionary  [
	^aDictionary at: aString
		ifAbsent: 
			[| variableNode |
			variableNode := RBPatternVariableNode named: aString.
			aDictionary at: variableNode ifAbsent: [nil]]
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>match: aNode inContext: aDictionary  [
	^self matchingBlock value: aNode value: aDictionary
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>matchingBlock [
	^ valueBlock ifNil: [valueBlock := self createMatchingBlock]
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>replacePatternNodesIn: aRBBlockNode  [
	aRBBlockNode body nodesDo: 
			[:each | 
			(each isVariable and: [each isPatternNode]) 
				ifTrue: 
					[each 
						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]
]

{
	#category : #matching,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>replacingBlock [
	^ valueBlock ifNil: [valueBlock := self createReplacingBlock]
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 07:16:40'
}
RBPatternBlockNode>>sentMessages [
	^ OrderedCollection new
]
