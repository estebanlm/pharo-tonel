"
This class models a scope for the workspace (and the debugger and all other tools).

The default scope of the compiler is initialized with a Requestor scope, if the requestor is not nil (see CompilationContext>>scope)

The OCRequestorScope will ask the tool (the requestor) for bindings. This will be an association, and as such it will create a OCLiteralVariable.  It will compile the same bytecode as for a global, but it will use the associations hold on by the tool to do so.
"
Class {
	#name : #OCRequestorScope,
	#superclass : #OCAbstractScope,
	#instVars : [
		'requestor',
		'compilationContext'
	],
	#category : #OpalCompiler-Core-Semantics,
	#timestamp : 'MarcusDenker 11/30/2016 14:10'
}

{
	#category : #'temp vars',
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>allTemps [
	^#()
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>compilationContext [
	^ compilationContext
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>compilationContext: anObject [
	compilationContext := anObject
]

{
	#category : #lookup,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>findVariable: aBlock ifNone: aNotFound [
	outerScope ifNotNil: [
		^  outerScope findVariable: aBlock ifNone: aNotFound ]
]

{
	#category : #lookup,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>lookupGlobalVar: aName [
	"consider variables with upper case as global vars resolveable in the outer scope "

	^ aName first isUppercase
		ifTrue: [ outerScope lookupVar: aName ]
		ifFalse: [ nil ]
]

{
	#category : #lookup,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>lookupVar: name [
	| global |
	name = 'self'
		ifTrue: [ ^ outerScope lookupVar: name ].
	name = 'super'
		ifTrue: [ ^ outerScope lookupVar: name ].
	global := self lookupGlobalVar: name.
	global ifNotNil: [ ^ global ].
	"do not 'create bindings' in requestor scope if we just want to style a possible unknown variable"
	(compilationContext forSyntaxHighlighting
		and: [ (requestor hasBindingOf: name asSymbol) not ])
		ifTrue: [ ^ super lookupVar: name ].

	"the requestors #bindingOf may create a binding for not yet existing variables"
	(requestor bindingOf: name asSymbol)
		ifNotNil: [ :assoc | 
			^ OCLiteralVariable new
				assoc: assoc;
				scope: self;
				yourself ].
	^ super lookupVar: name
]

{
	#category : #lookup,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>lookupVar: name inContext: context [

	name = 'self' ifTrue: [  ^outerScope lookupVar: name inContext: context outerContext].
	name = 'super' ifTrue: [  ^outerScope lookupVar: name inContext: context outerContext].
	name first isUppercase ifTrue: [ ^outerScope lookupVar: name inContext: context outerContext]. 
	
	(requestor bindingOf: name asSymbol) ifNotNil: [:assoc | 
		^ OCLiteralVariable new assoc: assoc; scope: self; yourself].
	^ super lookupVar: name inContext: context outerContext.
]

{
	#category : #lookup,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>newMethodScope [
	 
	^ OCMethodScope new outerScope: (self outerScope: outerScope instanceScope) 
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>requestor [
	^ requestor
]

{
	#category : #accessing,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>requestor: anObject [
	requestor := anObject
]

{
	#category : #lookup,
	#timestamp : ' 8/31/2017 07:16:23'
}
OCRequestorScope>>variableNamed: name ifAbsent: aBlock [

	name = 'self' ifTrue: [  ^outerScope lookupVar: name].
	name = 'super' ifTrue: [  ^outerScope lookupVar: name].
	name first isUppercase ifTrue: [ ^outerScope lookupVar: name ]. 
	
	(requestor bindingOf: name asSymbol) ifNotNil: [:assoc | 
		^ OCLiteralVariable new assoc: assoc; scope: self; yourself].

	^ aBlock value
]
