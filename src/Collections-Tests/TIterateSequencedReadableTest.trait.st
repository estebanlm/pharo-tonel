"
A trait for test purposes
"
Trait {
	#name : #TIterateSequencedReadableTest,
	#traits : '{}',
	#classTraits : '{}',
	#category : #Collections-Tests-Abstract,
	#timestamp : 'TorstenBergmann 2/20/2014 15:34'
}

{
	#category : #requirements,
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>empty [
	^self explicitRequirement.
]

{
	#category : #requirements,
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>nonEmptyMoreThan1Element [
" return a collection that doesn't includes equal elements' and doesn't include nil elements'" 
	^self explicitRequirement.
]

{
	#category : #'tests - fixture',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>test0FixtureIterateSequencedReadableTest [

	| res |
	
	self nonEmptyMoreThan1Element.
	self assert: self nonEmptyMoreThan1Element  size > 1.
	
	
	self empty.
	self assert: self empty isEmpty .
	
	res := true.
	self nonEmptyMoreThan1Element    
	detect: [ :each | (self nonEmptyMoreThan1Element    occurrencesOf: each) > 1 ]
	ifNone: [ res := false ].
	self assert: res = false.
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testAllButFirstDo [
	
	| result |
	result:= OrderedCollection  new.
	
	self nonEmptyMoreThan1Element  allButFirstDo: [:each | result add: each].
	
	1 to: (result size) do:
		[:i|
		self assert: (self nonEmptyMoreThan1Element  at:(i +1))=(result at:i)].
	
	self assert: result size=(self nonEmptyMoreThan1Element  size-1).
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testAllButLastDo [
	
	| result |
	result:= OrderedCollection  new.
	
	self nonEmptyMoreThan1Element  allButLastDo: [:each | result add: each].
	
	1 to: (result size) do:
		[:i|
		self assert: (self nonEmptyMoreThan1Element  at:(i ))=(result at:i)].
	
	self assert: result size=(self nonEmptyMoreThan1Element  size-1).
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testCollectFromTo [
	
	| result |
	result:=self nonEmptyMoreThan1Element 
		collect: [ :each | each ]
		from: 1
		to: (self nonEmptyMoreThan1Element size - 1).
		
	1 to: result size
		do: [ :i | self assert: (self nonEmptyMoreThan1Element at: i) = (result at: i) ].
	self assert: result size = (self nonEmptyMoreThan1Element size - 1)
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testDetectSequenced [
" testing that detect keep the first element returning true for sequenceable collections "

	| element result |
	element := self nonEmptyMoreThan1Element   at:1.
	result:=self nonEmptyMoreThan1Element  detect: [:each | each notNil ].
	self assert: result = element. 
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testDo [

]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testFindFirst [

	| element result |
	element := self nonEmptyMoreThan1Element   at:1.
	 result:=self nonEmptyMoreThan1Element  findFirst: [:each | each =element].
	
	self assert: result=1. 
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testFindFirstNotIn [

	| result |
	
	 result:=self empty findFirst: [:each | true].
	
	self assert: result=0. 
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testFindLast [

	| element result |
	element := self nonEmptyMoreThan1Element  at:self nonEmptyMoreThan1Element  size.
	 result:=self nonEmptyMoreThan1Element  findLast: [:each | each =element].
	
	self assert: result=self nonEmptyMoreThan1Element  size. 
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testFindLastNotIn [

	| result |
	
	 result:=self empty findFirst: [:each | true].
	
	self assert: result=0. 
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testFromToDo [
	
	| result |
	result:= OrderedCollection  new.
	
	self nonEmptyMoreThan1Element  from: 1 to: (self nonEmptyMoreThan1Element  size -1) do: [:each | result add: each].
	
	1 to: (self nonEmptyMoreThan1Element  size -1) do:
		[:i|
		self assert: (self nonEmptyMoreThan1Element  at:i )=(result at:i)].
	self assert: result size=(self nonEmptyMoreThan1Element  size-1).
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testKeysAndValuesDo [
	"| result |
	result:= OrderedCollection new.
	
	self nonEmptyMoreThan1Element  keysAndValuesDo: 
		[:i :value|
		result add: (value+i)].
	
	1 to: result size do:
		[:i|
		self assert: (result at:i)=((self nonEmptyMoreThan1Element at:i)+i)]"
	|  indexes elements |
	indexes:= OrderedCollection new.
	elements := OrderedCollection new.
	
	self nonEmptyMoreThan1Element  keysAndValuesDo: 
		[:i :value|
		indexes  add: (i).
		elements add: value].
	
	(1 to: self nonEmptyMoreThan1Element size )do:
		[ :i |
		self assert: (indexes at: i) = i.
		self assert: (elements at: i) = (self nonEmptyMoreThan1Element at: i).	
		].
	
	self assert: indexes size = elements size. 
	self assert: indexes size = self nonEmptyMoreThan1Element size . 
	
	
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testKeysAndValuesDoEmpty [
	| result |
	result:= OrderedCollection new.
	
	self empty  keysAndValuesDo: 
		[:i :value|
		result add: (value+i)].
	
	self assert: result isEmpty .
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testPairsCollect [
	
	| index result |
	index:=0.
	
	result:=self nonEmptyMoreThan1Element  pairsCollect: 
		[:each1 :each2 | 
		self assert: ( self nonEmptyMoreThan1Element indexOf: each2 ) = (index := index + 2).
		(self nonEmptyMoreThan1Element indexOf: each2) = ((self nonEmptyMoreThan1Element indexOf: each1) + 1).
		].
	
	result do: 
		[:each | self assert: each = true].
	

]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testPairsDo [
	| index |
	index:=1.
	
	self nonEmptyMoreThan1Element  pairsDo: 
		[:each1 :each2 | 
		self assert:(self nonEmptyMoreThan1Element at:index)=each1.
		self assert:(self nonEmptyMoreThan1Element at:(index+1))=each2.
		index:=index+2].
	
	self nonEmptyMoreThan1Element size odd
		ifTrue:[self assert: index=self nonEmptyMoreThan1Element size]
		ifFalse:[self assert: index=(self nonEmptyMoreThan1Element size+1)].
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testReverseDo [
	| result |
	result:= OrderedCollection new.
	self nonEmpty reverseDo: [: each | result add: each].
	
	1 to: result size do:
		[:i|
		self assert: (result at: i)=(self nonEmpty at:(self nonEmpty size-i+1))].
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testReverseDoEmpty [
	| result |
	result:= OrderedCollection new.
	self empty reverseDo: [: each | result add: each].
	
	self assert: result isEmpty .
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testReverseWithDo [
	
	| firstCollection secondCollection index |

	firstCollection := self nonEmptyMoreThan1Element.
	secondCollection := firstCollection copy.
	index := firstCollection size.
	
	firstCollection  reverseWith: secondCollection do:
		[:a :b |
	
		self assert: (firstCollection at: index) equals:  a. 
		self assert: (secondCollection at: index) equals:  b.
			( index := index - 1).]
	
	
	
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testWithCollect [
	
	| result firstCollection secondCollection index  |

	firstCollection := self nonEmptyMoreThan1Element.
	secondCollection := firstCollection copy.
	index := 0.
	
	result := firstCollection  with: secondCollection collect:
		[:a :b |
		( index := index + 1).
		self assert: (firstCollection at: index) equals:  a. 
		self assert: (secondCollection at: index) equals:  b.
		b].
	
	1 to: result size do:[: i | self assert: (result at:i)= (secondCollection  at: i)].
	self assert: result size = secondCollection  size.
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testWithCollectError [
	self should: [self nonEmptyMoreThan1Element with: self empty collect:[:a :b | ]] raise: Error.
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testWithDo [
	
	| firstCollection secondCollection index |

	firstCollection := self nonEmptyMoreThan1Element.
	secondCollection := firstCollection copy.
	index := 0.
	
	firstCollection  with: secondCollection do:
		[:a :b |
		( index := index + 1).
		self assert: (firstCollection at: index) equals:  a. 
		self assert: (secondCollection at: index) equals:  b.]
	
	
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testWithDoError [
	
	self should: [self nonEmptyMoreThan1Element with: self empty do:[:a :b | ]] raise: Error.
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testWithIndexCollect [
	
	| result index collection |
	index := 0.
	collection := self nonEmptyMoreThan1Element .
	result := collection  withIndexCollect: [:each :i | 
		self assert: i = (index := index + 1).	
		self assert: i = (collection  indexOf: each) .
		each] . 
	
	1 to: result size do:[: i | self assert: (result at:i)= (collection at: i)].
	self assert: result size = collection size.
]

{
	#category : #'tests - iterate on sequenced reable collections',
	#timestamp : ' 8/31/2017 05:26:28'
}
TIterateSequencedReadableTest>>testWithIndexDo [
	
	"| result |
	result:=Array new: self nonEmptyMoreThan1Element size.
	self nonEmptyMoreThan1Element  withIndexDo: [:each :i | result at:i put:(each+i)].
	
	1 to: result size do:[: i | self assert: (result at:i)= ((self nonEmptyMoreThan1Element at: i) + i)]"
	|  indexes elements |
	indexes:= OrderedCollection new.
	elements := OrderedCollection new.
	
	self nonEmptyMoreThan1Element  withIndexDo: 
		[:value :i  |
		indexes  add: (i).
		elements add: value].
	
	(1 to: self nonEmptyMoreThan1Element size )do:
		[ :i |
		self assert: (indexes at: i) = i.
		self assert: (elements at: i) = (self nonEmptyMoreThan1Element at: i).	
		].
	
	self assert: indexes size = elements size. 
	self assert: indexes size = self nonEmptyMoreThan1Element size . 
	
]
