"
I am a refactoring operations for adding method arguments.

You can modify the method name and add an additional keyword argument and the default value used by senders of the original method. Only one new argument can be added. But you can change the whole method name, as long as the number of argument matches.

For example, for #r:g:b:  add another parameter ""a"" the new method is
#r:g:b:a: 
or change the whole method to 
#setRed:green:blue:alpha:

This refactoring will add a new method with the new argument, remove the old method (for all implementors) and replace every sender of the prior method with the new one, using the specified default argument.
"
Class {
	#name : #RBAddParameterRefactoring,
	#superclass : #RBChangeMethodNameRefactoring,
	#instVars : [
		'initializer',
		'senders'
	],
	#category : #Refactoring-Core-Refactorings,
	#timestamp : 'NicolaiHess 8/6/2016 13:33'
}

{
	#category : #'instance creation',
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring class>>addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init  [
	^self new addParameterToMethod: aSelector
		in: aClass
		newSelector: newSelector
		initializer: init
]

{
	#category : #'instance creation',
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring class>>model: aRBSmalltalk addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init  [
	^(self new)
		model: aRBSmalltalk;
		addParameterToMethod: aSelector
			in: aClass
			newSelector: newSelector
			initializer: init;
		yourself
]

{
	#category : #initialize-release,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>addParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init  [
	self 
		renameMethod: aSelector
		in: aClass
		to: newSel
		permutation: (1 to: newSel numArgs).
	initializer := init
]

{
	#category : #preconditions,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>checkSendersAccessTo: name  [
	| violatorClass |
	(#('self' 'super') includes: name) ifTrue: [^self].
	violatorClass := self senders 
				detect: [:each | (self canReferenceVariable: name in: each) not]
				ifNone: [nil].
	violatorClass notNil 
		ifTrue: 
			[self refactoringError: ('<1s> doesn''t appear to be defined in <2p>' 
						expandMacrosWith: name
						with: violatorClass)]
]

{
	#category : #preconditions,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>checkVariableReferencesIn: aParseTree  [
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: '`var'
		do: 
			[:aNode :answer | 
			| name |
			name := aNode name.
			(aNode whoDefines: name) isNil ifTrue: [self checkSendersAccessTo: name]].
	searcher executeTree: aParseTree
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>modifyImplementorParseTree: parseTree in: aClass  [
	| name newArg allTempVars |
	allTempVars := parseTree allDefinedVariables.
	name := self safeVariableNameFor: aClass temporaries: allTempVars.
	newArg := RBVariableNode named: name.
	parseTree 
		renameSelector: newSelector
		andArguments: parseTree arguments , (Array with: newArg)
]

{
	#category : #preconditions,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>myConditions [
	^RBCondition withBlock: 
			[oldSelector numArgs + 1 = newSelector numArgs 
				ifFalse: 
					[self refactoringFailure: newSelector printString 
								, ' doesn''t have the proper number of arguments.'].
			self verifyInitializationExpression.
			true]
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>newSelectorString [
	| stream keywords |
	stream := WriteStream on: String new.
	keywords := newSelector keywords.
	1 to: keywords size
		do: 
			[:i | 
			stream nextPutAll: (keywords at: i).
			i == keywords size 
				ifTrue: 
					[stream
						nextPut: $(;
						nextPutAll: initializer;
						nextPut: $)]
				ifFalse: 
					[stream
						nextPutAll: ' ``@arg';
						nextPutAll: i printString].
			stream nextPut: $ ].
	^stream contents
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>parseTreeRewriter [
	| rewriteRule oldString newString |
	rewriteRule := RBParseTreeRewriter new.
	oldString := self buildSelectorString: oldSelector.
	newString := self newSelectorString.
	rewriteRule replace: '``@object ' , oldString
		with: '``@object ' , newString.
	^rewriteRule
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>safeVariableNameFor: aClass temporaries: allTempVars  [
	| baseString i newString |
	newString := baseString := 'anObject'.
	i := 0.
	
	[(allTempVars includes: newString) 
		or: [aClass definesInstanceVariable: newString]] 
			whileTrue: 
				[i := i + 1.
				newString := baseString , i printString].
	^newString
]

{
	#category : #private,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>senders [
	senders isNil 
		ifTrue: 
			[senders := Set new.
			self model allReferencesTo: oldSelector
				do: [:each | senders add: each modelClass]].
	^senders
]

{
	#category : #printing,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>storeOn: aStream  [
	aStream nextPut: $(.
	self class storeOn: aStream.
	aStream
		nextPutAll: ' addParameterToMethod: #';
		nextPutAll: oldSelector;
		nextPutAll: ' in: '.
	class storeOn: aStream.
	aStream
		nextPutAll: ' newSelector: #';
		nextPutAll: newSelector;
		nextPutAll: ' initializer: ''';
		nextPutAll: initializer;
		nextPutAll: ''')'
]

{
	#category : #preconditions,
	#timestamp : ' 8/31/2017 05:26:24'
}
RBAddParameterRefactoring>>verifyInitializationExpression [
	| tree |
	tree := RBParser parseExpression: initializer
				onError: 
					[:msg :index | 
					self refactoringFailure: 'Illegal initialization code because:.' , msg].
	tree isValue 
		ifFalse: 
			[self 
				refactoringFailure: 'The initialization code cannot be a return node or a list of statements'].
	self checkVariableReferencesIn: tree
]
